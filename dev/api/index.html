<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · DeadBird.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DeadBird.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../drosophila/"><em>Drosophila</em></a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/arzwa/DeadBird.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DeadBird.add_internal!-NTuple{5,Any}" href="#DeadBird.add_internal!-NTuple{5,Any}"><code>DeadBird.add_internal!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_internal!(dag, ndata, parts, x, n)</code></pre><p>For a species tree internal node <code>n</code>, this adds the gene family nodes associated with <code>n</code> to the graph and provides the bound on the number of lineages that survive to the present below <code>n</code> for each gene family.  Note that <code>x</code> is a vector of tuples of DAG nodes that each will be joined into a newly added node.  The resulting nodes are returned.</p><p>!!! note: I believe this also works for multifurcating species trees (like the Csuros Miklos algorithm does too)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/countdag.jl#L95-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.add_leaves!-NTuple{5,Any}" href="#DeadBird.add_leaves!-NTuple{5,Any}"><code>DeadBird.add_leaves!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_leaves!(dag, ndata, parts, x, n)</code></pre><p>For a species tree leaf node <code>n</code>, this adds the vector of (gene) counts <code>x</code> for that species to the graph.  This returns for each gene family the corresponding node that was added to the graph</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/countdag.jl#L77-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.cm!-Union{Tuple{T}, Tuple{CountDAG{T,G,I} where I where G,Any,Any}} where T" href="#DeadBird.cm!-Union{Tuple{T}, Tuple{CountDAG{T,G,I} where I where G,Any,Any}} where T"><code>DeadBird.cm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cm!(dag, node, model)</code></pre><p>Compute the conditional survival probabilities at <code>n</code> using the Csuros &amp; Miklos (2009) algorithm.  This assumes the <code>model</code> already contains the computed transition probability matrices <code>W</code> and that the partial loglikelihood vectors for the child nodes in the DAG are already computed and available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/linear.jl#L339-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.conditionfactor-Tuple{Any}" href="#DeadBird.conditionfactor-Tuple{Any}"><code>DeadBird.conditionfactor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conditionfactor(model)</code></pre><p>Compute the condition factor for the model for the associated data filtering strategy. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/linear.jl#L219-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.discretize-Tuple{Any,Any}" href="#DeadBird.discretize-Tuple{Any,Any}"><code>DeadBird.discretize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">discretize(d, K)</code></pre><p>Discretize a distribution <code>d</code> in <code>K</code> equal probability classes.  Uses the median of each class as representative rate, and rescales the resulting vector <code>x</code> so that <code>mean(x) == mean(d)</code>. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Better would be to have the mean value of each class as representative I guess, but the median is much more straightforward to obtain given that we have quantile functions available.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; discretize(Gamma(10, 0.1), 5)
5-element Array{Float64,1}:
 0.6269427439826725
 0.8195837806573205
 0.9743503743962694
 1.1475354999847722
 1.4315876009789656</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/utils.jl#L49-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.example_data-Tuple{}" href="#DeadBird.example_data-Tuple{}"><code>DeadBird.example_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">example_data()</code></pre><p>Get some example_data.</p><p><strong>Example (and benchmark)</strong></p><pre><code class="language-julia-repl">julia&gt; x = DeadBird.example_data();

julia&gt; @btime DeadBird.loglikelihood!(x.dag, x.model)
  36.974 μs (431 allocations: 31.53 KiB)
-26.30930561857625

julia&gt; @btime DeadBird.loglikelihood!(x.mat, x.model)
  32.876 μs (420 allocations: 29.91 KiB)
-26.309305618576246</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/DeadBird.jl#L28-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.extp-NTuple{4,Any}" href="#DeadBird.extp-NTuple{4,Any}"><code>DeadBird.extp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">extp(t, λ, μ, ϵ)</code></pre><p>Compute the extinction probability of a single lineage evolving according to a linear BDP for time <code>t</code> with rate <code>λ</code> and <code>μ</code> and with extinction probability of a single lineage at <code>t</code> equal to <code>ϵ</code>. This is <code>∑ᵢℙ{Xₜ=i|X₀=1}ϵ^i</code></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Takes ϵ on a [0,1] scale</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/linear.jl#L54-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.getθ-Union{Tuple{M}, Tuple{M,Any}} where M&lt;:DeadBird.RatesModel" href="#DeadBird.getθ-Union{Tuple{M}, Tuple{M,Any}} where M&lt;:DeadBird.RatesModel"><code>DeadBird.getθ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getθ(m&lt;:RatesModel, node)</code></pre><p>Get the parameter values from a <code>RatesModel</code> relevant for a particular node in a phylogeny. Should be implemented for each RatesModel where parameters differ across branches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/rmodels.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.getϕψ-Tuple{Any,Any,Any}" href="#DeadBird.getϕψ-Tuple{Any,Any,Any}"><code>DeadBird.getϕψ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getϕψ(t, λ, μ)</code></pre><p>Returns <code>ϕ = μ(eʳ - 1)/(λeʳ - μ)</code> where <code>r = t*(λ-μ)</code> and <code>ψ = ϕ*λ/μ</code>, with special cases for λ ≈ μ. These methods should be implemented as to prevent underflow/overflow issues.  Note these quantities are also called p and q (in Csuros &amp; Miklos) or α and β (in Bailey). Note that ϕ = P(Xₜ=0|X₀=1), i.e. the extinction probability for a single gene.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/linear.jl#L25-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.getϕψ′-Tuple{Any,Any,Any}" href="#DeadBird.getϕψ′-Tuple{Any,Any,Any}"><code>DeadBird.getϕψ′</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getϕψ′(ϕ, ψ, ϵ)</code></pre><p>Adjusted ϕ and ψ for a linear BDP process with extinction probability ϵ after the process.</p><p class="math-container">\[\phi&#39; = \frac{\psi(1-\epsilon) + (1 - \psi) \epsilon}{1 - \psi \epsilon}

\psi&#39; = \frac{\psi(1-\epsilon)}{1 - \psi \epsilon}\]</p><p>Some edge cases are when ϵ is 1 or 0. Other edge cases may be relevant when ψ and or ϕ is 1 or 0.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We take ϵ on [0,1] scale.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/linear.jl#L83-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.insertwgms-Union{Tuple{T}, Tuple{PhyloBDP{T,M,P,I} where I where P where M,Any}} where T" href="#DeadBird.insertwgms-Union{Tuple{T}, Tuple{PhyloBDP{T,M,P,I} where I where P where M,Any}} where T"><code>DeadBird.insertwgms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">insertwgms(model, wgms::Dict)</code></pre><p>Insert a bunch of WGMs in a given PhyloBDP model, will return a new model object. <code>wgms</code> should be a dict with vectors of tuples, keeping for each branch a vector with (t, k) tuples. This version does not modify anything in the template model.</p><p>This is not particularly convenient for use in rjMCMC algorithms, where we want to efficiently add and remove single WGM events...</p><p><strong>Example</strong></p><pre><code class="language-julia">x = DeadBird.example_data()
m = PhyloBDP(RatesModel(ConstantDLGWGD(q=ones(9))), x.tr, 5)
insertwgms(m, Dict(3=&gt;[(0.1, 2)], 2=&gt;[(0.3, 4)]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/wgmmodel.jl#L16-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.loglikelihood!-Union{Tuple{T}, Tuple{CountDAG,PhyloBDP{T,M,P,I} where I where P where M&lt;:(DeadBird.RatesModel{T} where T)}} where T" href="#DeadBird.loglikelihood!-Union{Tuple{T}, Tuple{CountDAG,PhyloBDP{T,M,P,I} where I where P where M&lt;:(DeadBird.RatesModel{T} where T)}} where T"><code>DeadBird.loglikelihood!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loglikelihood!(dag::CountDAG, model::PhyloBDP)</code></pre><p>Compute the log likelihood on the DAG using the Csuros &amp; Miklos algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/linear.jl#L257-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.marginal_extinctionp" href="#DeadBird.marginal_extinctionp"><code>DeadBird.marginal_extinctionp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">marginal_extinctionp(d, logϵ)</code></pre><p>Compute the marginal log probability of having no observed descendants for a branching process starting off with <code>n</code> genes given by a probability distribution <code>d</code>  when the probability that a single gene goes extinct is <code>ϵ</code>. This is:</p><p class="math-container">\[\sum_{k=1}^\infty ϵ^k P\{X₀ = k\}\]</p><p>For most priors a closed form can be obtained by manipulating the sum so that it becomes a geometric series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/rootprior.jl#L27-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.marginalize" href="#DeadBird.marginalize"><code>DeadBird.marginalize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">marginalize(prior, ℓvec, logϵ)</code></pre><p>Compute the log-likelihood of the data at the root by marginalizing the partial conditional survival likelihoods at the root over the prior on the number of genes at the root. This is the following sum</p><p class="math-container">\[\ell = \sum_{n=1}^{b} \ell[n] \Big( \sum_{i=0}^\infty 
    \binom{n+i}{i} \epsilon^i (1 - \epsilon)^n P\{X_o = n+i\} \Big)\]</p><p>Where <code>ℓ[n] = P{data|Yₒ=n}</code>, where <code>Yₒ</code> denotes the number of genes at the root that leave observed descendants and <code>Xₒ</code> denotes the total number of genes at the root, for which we specified the prior. <code>b</code> is the bound on the number of surviving lineages, which is determined by the observed data. For many priors, the innner infinite sum can be simplified to a closed form after some algebraic manipulation and relying on the fact that <code>∑ binom(α + k - 1, k) z^k = (1 - z)^(-k)</code> for <code>|z| &lt; 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/rootprior.jl#L5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.marginalize-Tuple{ShiftedBetaGeometric,Any,Any}" href="#DeadBird.marginalize-Tuple{ShiftedBetaGeometric,Any,Any}"><code>DeadBird.marginalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">marginalize(p::ShiftedBetaGeometric, ℓvec, logϵ)</code></pre><p>If we do the series, and make use of the fact that <code>B(x,y+1) = B(x,y)*y/(x+y)</code> We can obtain the following:</p><p class="math-container">\[\ell = \sum_{n=1}^b \ell[n] 
    \frac{\mathrm{B}(\alpha + 1, \beta + n + 1)}{\mathrm{B}(\alpha, \beta)}
    \frac{(1-\epsilon)^n}{(1-\epsilon \frac{\beta + n-1}{\alpha + \beta + n})^{n+1}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/rootprior.jl#L132-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.newmodel-Union{Tuple{M}, Tuple{M,Any}} where M&lt;:DeadBird.RatesModel" href="#DeadBird.newmodel-Union{Tuple{M}, Tuple{M,Any}} where M&lt;:DeadBird.RatesModel"><code>DeadBird.newmodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">newmodel(m::M, θ) where M&lt;:RatesModel</code></pre><p>Construct a new model of type <code>M</code> by taking the parameters of <code>m</code> and parameters defined in the named tuple <code>θ</code>, the latter overriding the former.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/rmodels.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.nonextinctfromrootcondition-Tuple{Any}" href="#DeadBird.nonextinctfromrootcondition-Tuple{Any}"><code>DeadBird.nonextinctfromrootcondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nonextinctfromrootcondition(model)</code></pre><p>Compute the probability that a family existing at the root of the species tree leaves observed descendants in both clades stemming from the root, i.e. does not go extinct in any of the two clades stemming from the root. This uses the marginalization of the extinction probability over the prior distribution on the number of genes at the root using <a href="#DeadBird.marginal_extinctionp"><code>marginal_extinctionp</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/linear.jl#L235-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.simulate" href="#DeadBird.simulate"><code>DeadBird.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simulate(m::ModelArray)
simulate(m::MixtureModel, n)
simulate(m::PhyloBDP, n)</code></pre><p>Simulate a set of random profiles from a phylogenetic birth-death model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; x = DeadBird.example_data();

julia&gt; simulate(x.model, 5)
5×5 DataFrame
│ Row │ A     │ B     │ C     │ rejected │ extinct │
│     │ Int64 │ Int64 │ Int64 │ Int64    │ Int64   │
├─────┼───────┼───────┼───────┼──────────┼─────────┤
│ 1   │ 1     │ 1     │ 1     │ 0        │ 0       │
│ 2   │ 1     │ 1     │ 1     │ 0        │ 0       │
│ 3   │ 2     │ 2     │ 2     │ 0        │ 0       │
│ 4   │ 0     │ 1     │ 1     │ 1        │ 1       │
│ 5   │ 1     │ 1     │ 1     │ 0        │ 0       │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/dlsim.jl#L28-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.simulate" href="#DeadBird.simulate"><code>DeadBird.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simulate(mfun::Function, data::DataFrame, chain, N)</code></pre><p>Perform posterior predictive simulations. <code>mfun</code> should be a function that takes an iterate of the <code>chain</code> and returns a <code>PhyloBDP</code> model,  i.e. <code>mfun(chain[i])</code> should return a parameterized model. <code>data</code> is the observed data set to which posterior predictive simulations should correspond.</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; x = DeadBird.example_data();

julia&gt; DeadBird.simulate(y-&gt;x.model((λ=y, μ=y)), x.df, ones(10), 100)
PP simulations (N = 100, n = 10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/ppsim.jl#L60-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.wgmϵ-Tuple{Any,Any,Any}" href="#DeadBird.wgmϵ-Tuple{Any,Any,Any}"><code>DeadBird.wgmϵ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wgmϵ(q, k, logϵ)</code></pre><p>Compute the log-extinction probability of a single lineage going through a k-plication event, given the extinction probability of a single lineage after the WGM event. Assumes the single parameter WGM retention model (assuming a single gene before the WGM, the number of retained genes after the WGM is a rv X&#39; = 1 + Y where Y is Binomial(k - 1, q)).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/linear.jl#L134-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.wstar!-Union{Tuple{T}, Tuple{AbstractArray{T,2},Any,Any,Any}} where T" href="#DeadBird.wstar!-Union{Tuple{T}, Tuple{AbstractArray{T,2},Any,Any,Any}} where T"><code>DeadBird.wstar!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wstar!(w::Matrix, t, θ, ϵ)</code></pre><p>Compute the transition probabilities for the conditional survival process recursively (not implemented using recursion though!). Note that the resulting transition matrix is <em>not</em> a stochastic matrix of some Markov chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/linear.jl#L157-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.ConstantDLG" href="#DeadBird.ConstantDLG"><code>DeadBird.ConstantDLG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstantDLG{T}</code></pre><p>Simple constant rates duplication-loss and gain model. All nodes of the tree are associated with the same parameters (duplication rate λ, loss rate μ, gain rate κ). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.ConstantDLGWGM" href="#DeadBird.ConstantDLGWGM"><code>DeadBird.ConstantDLGWGM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstantDLGWGM{T}</code></pre><p>Similar to <code>ConstantDLG</code>, but with a field for whole-genome multiplication (WGM) nodes in the phylogeny, which have a single retention rate parameter <code>q</code> each.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.CountDAG" href="#DeadBird.CountDAG"><code>DeadBird.CountDAG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CountDAG(df::DataFrame, tree::Node)</code></pre><p>Get a <code>CountDAG</code> from a count matrix, i.e. the directed acyclic graph (DAG) representation of a phylogenetic profile for an (assumed known) species tree. This is a <a href="https://en.wikipedia.org/wiki/Multitree">multitree</a>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; x = DeadBird.example_data();

julia&gt; dag = CountDAG(x.df, x.tr)
(dag = CountDAG({17, 20} directed simple Int64 graph), bound = 7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/countdag.jl#L15-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.DLG" href="#DeadBird.DLG"><code>DeadBird.DLG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DLG{T}</code></pre><p>Simple branch-wise rates duplication-loss and gain model.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.DLGWGM" href="#DeadBird.DLGWGM"><code>DeadBird.DLGWGM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DLGWGM{T}</code></pre><p>Similar to <code>DLG</code>, but with WGM nodes, see also <code>ConstantDLGWGM</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.NodeData" href="#DeadBird.NodeData"><code>DeadBird.NodeData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NodeData{I}</code></pre><p>Keeps some relevant information for nodes in the DAG representation of a phylogenetic profile matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/countdag.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.PPSim" href="#DeadBird.PPSim"><code>DeadBird.PPSim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PPPSim</code></pre><p>Container for posterior predictive simulations, constructor should not be called directly nor exported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/ppsim.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.PhyloBDP" href="#DeadBird.PhyloBDP"><code>DeadBird.PhyloBDP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PhyloBDP(ratesmodel, tree, bound)</code></pre><p>The phylogenetic birth-death process model as defined by Csuros &amp; Miklos (2009). The bound is exactly defined by the data under consideration.</p><p>!!! note: implemented as a <code>&lt;: DiscreteMultivariateDistribution</code> (for     convenience with Turing.jl), however does not support a lot of the     Distributions.jl interface.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; x = DeadBird.example_data();

julia&gt; rates = RatesModel(ConstantDLG(λ=0.1, μ=0.1));

julia&gt; dag, bound = CountDAG(x.df, x.tr);

julia&gt; rates = RatesModel(ConstantDLG(λ=0.1, μ=0.1));

julia&gt; PhyloBDP(rates, x.tr, bound)
PhyloBDP(
~root
RatesModel with () fixed
ConstantDLG{Float64}
  λ: Float64 0.1
  μ: Float64 0.1
  κ: Float64 0.0
  η: Float64 0.66
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/model.jl#L51-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.Profile" href="#DeadBird.Profile"><code>DeadBird.Profile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Profile{T,I}</code></pre><p>A phylogenetic profile, i.e. an observation of a discrete random variable associated with the leaves of a phylogenetic tree. This has a field <code>x</code> for the extended profile (which records the bound on the number of lineages that survive below an internal node for internal nodes) and a field for the &#39;partial likelihoods&#39; <code>ℓ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/profile.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.ProfileMatrix" href="#DeadBird.ProfileMatrix"><code>DeadBird.ProfileMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProfileMatrix(df::DataFrame, tree)</code></pre><p>Obtain a ProfileMatrix struct for a count dataframe.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; x = DeadBird.example_data();

julia&gt; mat, bound = ProfileMatrix(x.df, x.tr)
(matrix = Profile{Float64,Int64}[2 1 … 0 1; 3 2 … 1 1; 7 3 … 0 4; 7 3 … 3 4], bound = 7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/profile.jl#L27-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.RatesModel" href="#DeadBird.RatesModel"><code>DeadBird.RatesModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RatesModel</code></pre><p>Abstract type for diferent rate models for phylogenies (e.g. constant rates across the tree, branch-specific rates, models with WGD nodes, ...).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/rmodels.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.ShiftedBetaGeometric" href="#DeadBird.ShiftedBetaGeometric"><code>DeadBird.ShiftedBetaGeometric</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ShiftedBetaGeometric(η, ζ)</code></pre><p>Beta-Geometric compound distribution on the domain [1, 2, ..., ∞).  The pmf is given by</p><p class="math-container">\[p_k = \frac{\mathrm{B}(\alpha + 1, \beta + k - 1)}{\mathrm{B}(\alpha, \beta)}\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We use the alternative parameterization using the mean <code>η = α/(α+β)</code> and <em>offset</em> &#39;sample size&#39; <code>ζ = α + β - 1</code>, where <code>ζ &gt; 0</code>. That is, we assume <code>α + β &gt; 1</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/rootprior.jl#L102-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.ShiftedGeometric" href="#DeadBird.ShiftedGeometric"><code>DeadBird.ShiftedGeometric</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ShiftedGeometric</code></pre><p>Geometric distribution with domain [1, 2, ..., ∞).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/ea43a55983b78b57106b2503e7967ba5eb7f4e72/src/rootprior.jl#L69-L73">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../drosophila/">« <em>Drosophila</em></a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 4 January 2021 08:34">Monday 4 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
