<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · DeadBird.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DeadBird.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../drosophila/"><em>Drosophila</em></a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/arzwa/DeadBird.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DeadBird.add_internal!-NTuple{5, Any}" href="#DeadBird.add_internal!-NTuple{5, Any}"><code>DeadBird.add_internal!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_internal!(dag, ndata, parts, x, n)</code></pre><p>For a species tree internal node <code>n</code>, this adds the gene family nodes associated with <code>n</code> to the graph and provides the bound on the number of lineages that survive to the present below <code>n</code> for each gene family.  Note that <code>x</code> is a vector of tuples of DAG nodes that each will be joined into a newly added node.  The resulting nodes are returned.</p><p>!!! note: I believe this also works for multifurcating species trees (like the Csuros Miklos algorithm does too)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/countdag.jl#L95-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.add_leaves!-NTuple{5, Any}" href="#DeadBird.add_leaves!-NTuple{5, Any}"><code>DeadBird.add_leaves!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_leaves!(dag, ndata, parts, x, n)</code></pre><p>For a species tree leaf node <code>n</code>, this adds the vector of (gene) counts <code>x</code> for that species to the graph.  This returns for each gene family the corresponding node that was added to the graph</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/countdag.jl#L77-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.cm!-Union{Tuple{T}, Tuple{CountDAG{T}, Any, Any}} where T" href="#DeadBird.cm!-Union{Tuple{T}, Tuple{CountDAG{T}, Any, Any}} where T"><code>DeadBird.cm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cm!(dag, node, model)</code></pre><p>Compute the conditional survival probabilities at <code>n</code> using the Csuros &amp; Miklos (2009) algorithm.  This assumes the <code>model</code> already contains the computed transition probability matrices <code>W</code> and that the partial loglikelihood vectors for the child nodes in the DAG are already computed and available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/linear.jl#L377-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.conditionfactor-Tuple{Any}" href="#DeadBird.conditionfactor-Tuple{Any}"><code>DeadBird.conditionfactor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conditionfactor(model)</code></pre><p>Compute the condition factor for the model for the associated data filtering strategy. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/linear.jl#L257-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.discretize-Tuple{Any, Any}" href="#DeadBird.discretize-Tuple{Any, Any}"><code>DeadBird.discretize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">discretize(d, K)</code></pre><p>Discretize a distribution <code>d</code> in <code>K</code> equal probability classes.  Uses the median of each class as representative rate, and rescales the resulting vector <code>x</code> so that <code>mean(x) == mean(d)</code>. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Better would be to have the mean value of each class as representative I guess, but the median is much more straightforward to obtain given that we have quantile functions available.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; discretize(Gamma(10, 0.1), 5)
5-element Array{Float64,1}:
 0.6269427439826725
 0.8195837806573205
 0.9743503743962694
 1.1475354999847722
 1.4315876009789656</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/utils.jl#L49-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.example_data-Tuple{}" href="#DeadBird.example_data-Tuple{}"><code>DeadBird.example_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">example_data()</code></pre><p>Get some example_data.</p><p><strong>Example (and benchmark)</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = DeadBird.example_data();

julia&gt; @btime DeadBird.loglikelihood!(x.dag, x.model)
  36.974 μs (431 allocations: 31.53 KiB)
-26.30930561857625

julia&gt; @btime DeadBird.loglikelihood!(x.mat, x.model)
  32.876 μs (420 allocations: 29.91 KiB)
-26.309305618576246</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/DeadBird.jl#L29-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.extp-NTuple{4, Any}" href="#DeadBird.extp-NTuple{4, Any}"><code>DeadBird.extp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extp(t, λ, μ, ϵ)</code></pre><p>Compute the extinction probability of a single lineage evolving according to a linear BDP for time <code>t</code> with rate <code>λ</code> and <code>μ</code> and with extinction probability of a single lineage at <code>t</code> equal to <code>ϵ</code>. This is <code>∑ᵢℙ{Xₜ=i|X₀=1}ϵ^i</code></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Takes ϵ on a [0,1] scale</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/linear.jl#L54-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.getθ-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:DeadBird.RatesModel" href="#DeadBird.getθ-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:DeadBird.RatesModel"><code>DeadBird.getθ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getθ(m&lt;:RatesModel, node)</code></pre><p>Get the parameter values from a <code>RatesModel</code> relevant for a particular node in a phylogeny. Should be implemented for each RatesModel where parameters differ across branches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/rmodels.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.getϕψ-Tuple{Any, Any, Any}" href="#DeadBird.getϕψ-Tuple{Any, Any, Any}"><code>DeadBird.getϕψ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getϕψ(t, λ, μ)</code></pre><p>Returns <code>ϕ = μ(eʳ - 1)/(λeʳ - μ)</code> where <code>r = t*(λ-μ)</code> and <code>ψ = ϕ*λ/μ</code>, with special cases for λ ≈ μ. These methods should be implemented as to prevent underflow/overflow issues.  Note these quantities are also called p and q (in Csuros &amp; Miklos) or α and β (in Bailey). Note that ϕ = P(Xₜ=0|X₀=1), i.e. the extinction probability for a single gene.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/linear.jl#L25-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.getϕψ′-Tuple{Any, Any, Any}" href="#DeadBird.getϕψ′-Tuple{Any, Any, Any}"><code>DeadBird.getϕψ′</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getϕψ′(ϕ, ψ, ϵ)</code></pre><p>Adjusted ϕ and ψ for a linear BDP process with extinction probability ϵ after the process.</p><p class="math-container">\[\phi&#39; = \frac{\psi(1-\epsilon) + (1 - \psi) \epsilon}{1 - \psi \epsilon}

\psi&#39; = \frac{\psi(1-\epsilon)}{1 - \psi \epsilon}\]</p><p>Some edge cases are when ϵ is 1 or 0. Other edge cases may be relevant when ψ and or ϕ is 1 or 0.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We take ϵ on [0,1] scale.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/linear.jl#L83-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.insertwgms-Union{Tuple{T}, Tuple{PhyloBDP{T}, Any}} where T" href="#DeadBird.insertwgms-Union{Tuple{T}, Tuple{PhyloBDP{T}, Any}} where T"><code>DeadBird.insertwgms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insertwgms(model, wgms::Dict)</code></pre><p>Insert a bunch of WGMs in a given PhyloBDP model, will return a new model object. <code>wgms</code> should be a dict with vectors of tuples, keeping for each branch a vector with (t, k) tuples. This version does not modify anything in the template model.</p><p>This is not particularly convenient for use in rjMCMC algorithms, where we want to efficiently add and remove single WGM events...</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">x = DeadBird.example_data()
m = PhyloBDP(RatesModel(ConstantDLGWGD(q=ones(9))), x.tr, 5)
insertwgms(m, Dict(3=&gt;[(0.1, 2)], 2=&gt;[(0.3, 4)]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/wgmmodel.jl#L16-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.loglikelihood!-Union{Tuple{T}, Tuple{CountDAG, PhyloBDP{T, M} where M&lt;:(DeadBird.RatesModel)}} where T" href="#DeadBird.loglikelihood!-Union{Tuple{T}, Tuple{CountDAG, PhyloBDP{T, M} where M&lt;:(DeadBird.RatesModel)}} where T"><code>DeadBird.loglikelihood!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loglikelihood!(dag::CountDAG, model::PhyloBDP)</code></pre><p>Compute the log likelihood on the DAG using the Csuros &amp; Miklos algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/linear.jl#L295-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.marginal_extinctionp" href="#DeadBird.marginal_extinctionp"><code>DeadBird.marginal_extinctionp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">marginal_extinctionp(d, logϵ)</code></pre><p>Compute the marginal log probability of having no observed descendants for a branching process starting off with <code>n</code> genes given by a probability distribution <code>d</code>  when the probability that a single gene goes extinct is <code>ϵ</code>. This is:</p><p class="math-container">\[\sum_{k=1}^\infty ϵ^k P\{X₀ = k\}\]</p><p>For many priors a closed form can be obtained by manipulating the sum so that it becomes a geometric series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/rootprior.jl#L27-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.marginalize" href="#DeadBird.marginalize"><code>DeadBird.marginalize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">marginalize(p::ShiftedBetaGeometric, ℓvec, logϵ, imax=100)</code></pre><p>There seems to be no closed form for this, but we can devise a recursion and obtain a near-exact solution efficiently.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/rootprior.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.marginalize" href="#DeadBird.marginalize"><code>DeadBird.marginalize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">marginalize(p::ShiftedBetaGeometric, ℓvec, logϵ, imax=100)</code></pre><p>There seems to be no closed form for this, but we can devise a recursion, analogous to the ShiftedBetaGeometric case. This could probably share code, but I&#39;ll have it separate for now.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/rootprior.jl#L195-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.marginalize" href="#DeadBird.marginalize"><code>DeadBird.marginalize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">marginalize(prior, ℓvec, logϵ)</code></pre><p>Compute the log-likelihood of the data at the root by marginalizing the partial conditional survival likelihoods at the root over the prior on the number of genes at the root. This is the following sum</p><p class="math-container">\[\ell = \sum_{n=1}^{b} \ell[n] \Big( \sum_{i=0}^\infty 
    \binom{n+i}{i} \epsilon^i (1 - \epsilon)^n P\{X_o = n+i\} \Big)\]</p><p>Where <code>ℓ[n] = P{data|Yₒ=n}</code>, where <code>Yₒ</code> denotes the number of genes at the root that leave observed descendants and <code>Xₒ</code> denotes the total number of genes at the root, for which we specified the prior. <code>b</code> is the bound on the number of surviving lineages, which is determined by the observed data. For many priors, the innner infinite sum can be simplified to a closed form after some algebraic manipulation and relying on the fact that <code>∑ binom(α + k - 1, k) z^k = (1 - z)^(-k)</code> for <code>|z| &lt; 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/rootprior.jl#L5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.newmodel-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:DeadBird.RatesModel" href="#DeadBird.newmodel-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:DeadBird.RatesModel"><code>DeadBird.newmodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newmodel(m::M, θ) where M&lt;:RatesModel</code></pre><p>Construct a new model of type <code>M</code> by taking the parameters of <code>m</code> and parameters defined in the named tuple <code>θ</code>, the latter overriding the former.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/rmodels.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.nonextinctfromrootcondition-Tuple{Any}" href="#DeadBird.nonextinctfromrootcondition-Tuple{Any}"><code>DeadBird.nonextinctfromrootcondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nonextinctfromrootcondition(model)</code></pre><p>Compute the probability that a family existing at the root of the species tree leaves observed descendants in both clades stemming from the root, i.e. does not go extinct in any of the two clades stemming from the root. This uses the marginalization of the extinction probability over the prior distribution on the number of genes at the root using <a href="#DeadBird.marginal_extinctionp"><code>marginal_extinctionp</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/linear.jl#L273-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.ppmf-Tuple{NewickTree.Node{I, DeadBird.NodeProbs{T}} where {T, I}, Profile, Any, Any}" href="#DeadBird.ppmf-Tuple{NewickTree.Node{I, DeadBird.NodeProbs{T}} where {T, I}, Profile, Any, Any}"><code>DeadBird.ppmf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ppmf(node, x, prior, bound)</code></pre><p>Compute the posterior pmf for the ancestral state at node <code>node</code>, where <code>x</code> holds the partial likelihoods somewhere, and <code>prior</code> corresponds to the root or transition probability density that acts as a prior on the node state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/ancestral.jl#L100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.sample_ancestral-Tuple{DeadBird.AncestralSampler, Any}" href="#DeadBird.sample_ancestral-Tuple{DeadBird.AncestralSampler, Any}"><code>DeadBird.sample_ancestral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_ancestral(spl::AncestralSampler, x)</code></pre><p>Sample a set of ancestral states using a pre-order traversal over the tree. This assumes the partial likelihoods are available in <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/ancestral.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.sample_ancestral_node-Tuple{Random.AbstractRNG, Any, Any, Any, Any}" href="#DeadBird.sample_ancestral_node-Tuple{Random.AbstractRNG, Any, Any, Any, Any}"><code>DeadBird.sample_ancestral_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_ancestral_node(rng, node, x, prior, bound)</code></pre><p>Sample ancestral state for node <code>node</code> with <code>prior</code> prior and relevant partial likelihoods computed in <code>x</code>. The prior refers to either a root prior distribution or the transient probability distribution of the process given the parent state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/ancestral.jl#L82-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.setw!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Any}} where T" href="#DeadBird.setw!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Any}} where T"><code>DeadBird.setw!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setw!(W, θ, t)</code></pre><p>Compute transition probability matrix for the ordinary (not conditional on survival that is) birth-death process. Using the recursive formulation of Csuros &amp; Miklos.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/linear.jl#L216-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.simulate" href="#DeadBird.simulate"><code>DeadBird.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate(mfun::Function, data::DataFrame, chain, N)</code></pre><p>Perform posterior predictive simulations. <code>mfun</code> should be a function that takes an iterate of the <code>chain</code> and returns a <code>PhyloBDP</code> model,  i.e. <code>mfun(chain[i])</code> should return a parameterized model. <code>data</code> is the observed data set to which posterior predictive simulations should correspond.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; x = DeadBird.example_data();

julia&gt; DeadBird.simulate(y-&gt;x.model((λ=y, μ=y)), x.df, ones(10), 100)
PP simulations (N = 100, n = 10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/ppsim.jl#L60-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.simulate" href="#DeadBird.simulate"><code>DeadBird.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate(m::ModelArray)
simulate(m::MixtureModel, n)
simulate(m::PhyloBDP, n)</code></pre><p>Simulate a set of random profiles from a phylogenetic birth-death model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = DeadBird.example_data();

julia&gt; simulate(x.model, 5)
5×5 DataFrame
│ Row │ A     │ B     │ C     │ rejected │ extinct │
│     │ Int64 │ Int64 │ Int64 │ Int64    │ Int64   │
├─────┼───────┼───────┼───────┼──────────┼─────────┤
│ 1   │ 1     │ 1     │ 1     │ 0        │ 0       │
│ 2   │ 1     │ 1     │ 1     │ 0        │ 0       │
│ 3   │ 2     │ 2     │ 2     │ 0        │ 0       │
│ 4   │ 0     │ 1     │ 1     │ 1        │ 1       │
│ 5   │ 1     │ 1     │ 1     │ 0        │ 0       │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/dlsim.jl#L28-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.wgmϵ-Tuple{Any, Any, Any}" href="#DeadBird.wgmϵ-Tuple{Any, Any, Any}"><code>DeadBird.wgmϵ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wgmϵ(q, k, logϵ)</code></pre><p>Compute the log-extinction probability of a single lineage going through a k-plication event, given the extinction probability of a single lineage after the WGM event. Assumes the single parameter WGM retention model (assuming a single gene before the WGM, the number of retained genes after the WGM is a rv X&#39; = 1 + Y where Y is Binomial(k - 1, q)).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/linear.jl#L134-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.wstar!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Any, Any}} where T" href="#DeadBird.wstar!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Any, Any}} where T"><code>DeadBird.wstar!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wstar!(W::Matrix, t, θ, ϵ)</code></pre><p>Compute the transition probabilities for the conditional survival process recursively (not implemented using recursion though!). Note that the resulting transition matrix is <em>not</em> a stochastic matrix of some Markov chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/linear.jl#L157-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.AncestralSampler" href="#DeadBird.AncestralSampler"><code>DeadBird.AncestralSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AncestralSampler(model, bound)</code></pre><p>A wrapper that contains the transition probability matrices for the transient distributions for the PhyloBDP (not conditioned on survival) along each branch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/ancestral.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.BetaGeometric" href="#DeadBird.BetaGeometric"><code>DeadBird.BetaGeometric</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BetaGeometric(η, ζ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/rootprior.jl#L177-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.ConstantDLG" href="#DeadBird.ConstantDLG"><code>DeadBird.ConstantDLG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantDLG{T}</code></pre><p>Simple constant rates duplication-loss and gain model. All nodes of the tree are associated with the same parameters (duplication rate λ, loss rate μ, gain rate κ). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/rmodels.jl#L36-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.ConstantDLGWGM" href="#DeadBird.ConstantDLGWGM"><code>DeadBird.ConstantDLGWGM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantDLGWGM{T}</code></pre><p>Similar to <code>ConstantDLG</code>, but with a field for whole-genome multiplication (WGM) nodes in the phylogeny, which have a single retention rate parameter <code>q</code> each.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/rmodels.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.CountDAG" href="#DeadBird.CountDAG"><code>DeadBird.CountDAG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CountDAG(df::DataFrame, tree::Node)</code></pre><p>Get a <code>CountDAG</code> from a count matrix, i.e. the directed acyclic graph (DAG) representation of a phylogenetic profile for an (assumed known) species tree. This is a <a href="https://en.wikipedia.org/wiki/Multitree">multitree</a>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = DeadBird.example_data();

julia&gt; dag = CountDAG(x.df, x.tr)
(dag = CountDAG({17, 20} directed simple Int64 graph), bound = 7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/countdag.jl#L15-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.DLG" href="#DeadBird.DLG"><code>DeadBird.DLG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DLG{T}</code></pre><p>Simple branch-wise rates duplication-loss and gain model.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/rmodels.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.DLGWGM" href="#DeadBird.DLGWGM"><code>DeadBird.DLGWGM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DLGWGM{T}</code></pre><p>Similar to <code>DLG</code>, but with WGM nodes, see also <code>ConstantDLGWGM</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/rmodels.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.NodeData" href="#DeadBird.NodeData"><code>DeadBird.NodeData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodeData{I}</code></pre><p>Keeps some relevant information for nodes in the DAG representation of a phylogenetic profile matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/countdag.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.PPSim" href="#DeadBird.PPSim"><code>DeadBird.PPSim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PPPSim</code></pre><p>Container for posterior predictive simulations, constructor should not be called directly nor exported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/ppsim.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.PhyloBDP" href="#DeadBird.PhyloBDP"><code>DeadBird.PhyloBDP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PhyloBDP(ratesmodel, tree, bound)</code></pre><p>The phylogenetic birth-death process model as defined by Csuros &amp; Miklos (2009). The bound is exactly defined by the data under consideration.</p><p>!!! note: implemented as a <code>&lt;: DiscreteMultivariateDistribution</code> (for     convenience with Turing.jl), however does not support a lot of the     Distributions.jl interface.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = DeadBird.example_data();

julia&gt; rates = RatesModel(ConstantDLG(λ=0.1, μ=0.1));

julia&gt; dag, bound = CountDAG(x.df, x.tr);

julia&gt; rates = RatesModel(ConstantDLG(λ=0.1, μ=0.1));

julia&gt; PhyloBDP(rates, x.tr, bound)
PhyloBDP(
~root
RatesModel with () fixed
ConstantDLG{Float64}
  λ: Float64 0.1
  μ: Float64 0.1
  κ: Float64 0.0
  η: Float64 0.66
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/model.jl#L51-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.Profile" href="#DeadBird.Profile"><code>DeadBird.Profile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Profile{T,I}</code></pre><p>A phylogenetic profile, i.e. an observation of a discrete random variable associated with the leaves of a phylogenetic tree. This has a field <code>x</code> for the extended profile (which records the bound on the number of lineages that survive below an internal node for internal nodes) and a field for the &#39;partial likelihoods&#39; <code>ℓ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/profile.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.ProfileMatrix" href="#DeadBird.ProfileMatrix"><code>DeadBird.ProfileMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProfileMatrix(df::DataFrame, tree)</code></pre><p>Obtain a ProfileMatrix struct for a count dataframe.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = DeadBird.example_data();

julia&gt; mat, bound = ProfileMatrix(x.df, x.tr)
(matrix = Profile{Float64,Int64}[2 1 … 0 1; 3 2 … 1 1; 7 3 … 0 4; 7 3 … 3 4], bound = 7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/profile.jl#L27-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.RatesModel" href="#DeadBird.RatesModel"><code>DeadBird.RatesModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RatesModel</code></pre><p>Abstract type for diferent rate models for phylogenies (e.g. constant rates across the tree, branch-specific rates, models with WGD nodes, ...).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/rmodels.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.ShiftedBetaGeometric" href="#DeadBird.ShiftedBetaGeometric"><code>DeadBird.ShiftedBetaGeometric</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShiftedBetaGeometric(η, ζ)</code></pre><p>Beta-Geometric compound distribution on the domain [1, 2, ..., ∞).  The pmf is given by</p><p class="math-container">\[p_k = \frac{\mathrm{B}(\alpha + 1, \beta + k - 1)}{\mathrm{B}(\alpha, \beta)}\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We use the alternative parameterization using the mean <code>η = α/(α+β)</code> and <em>offset</em> &#39;sample size&#39; <code>ζ = α + β - 1</code>, where <code>ζ &gt; 0</code>. That is, we assume <code>α + β &gt; 1</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/rootprior.jl#L102-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.ShiftedGeometric" href="#DeadBird.ShiftedGeometric"><code>DeadBird.ShiftedGeometric</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShiftedGeometric</code></pre><p>Geometric distribution with domain [1, 2, ..., ∞).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/rootprior.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DeadBird.Transient" href="#DeadBird.Transient"><code>DeadBird.Transient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Transient</code></pre><p>Transient distribution P(X(t)|X(0)=k). This is a simple struct for the sampler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arzwa/DeadBird.jl/blob/e768df1e5aee00582f1c2d42ee9bb18743528360/src/ancestral.jl#L34-L38">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../drosophila/">« <em>Drosophila</em></a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Thursday 27 January 2022 11:27">Thursday 27 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
